# データセット前処理パイプライン

このドキュメントは、頸椎CT画像からAIモデル学習用のデータセットを生成する前処理パイプラインについて説明します。
パイプラインは `generate_dataset.py` スクリプトによって実行されます。

## 1. 概要

このパイプラインの目的は、生のNIfTI形式のCT画像、椎骨セグメンテーションマスク、および骨折ラベルから、各頸椎（C1〜C7）に焦点を当てた、位置と向きを正規化した3Dボリュームデータを生成することです。

生成されるデータは、骨折分類モデルの学習に使用されます。

## 2. ディレクトリ構造と入力ファイル

パイプラインを実行する前に、以下のファイルとディレクトリを準備する必要があります。

```
.
├── generate_dataset.py       # このパイプラインの実行スクリプト
├── nifti_list.csv            # 処理対象のサンプルIDリスト
├── nifti_output/             # NIfTI形式のCT画像
│   └── {sample_id}.nii.gz
├── segmentations/            # 椎骨ごとのセグメンテーションマスク
│   └── {sample_id}/
│       └── vertebrae_{vertebra_id}.nii.gz
└── fracture_labels/          # 骨折領域のマスク
    └── {sample_id}.nii.gz
```

### 各ファイルの詳細

- **`nifti_list.csv`**:
  - `ID`カラムに処理対象のサンプルIDを記載したCSVファイル。
  - `Exclude`カラムが `True` のサンプルは処理から除外されます。
- **`nifti_output/`**:
  - `nifti_list.csv` のIDに対応するCT画像（`.nii.gz`形式）を格納します。
- **`segmentations/`**:
  - TotalSegmentatorなどによって生成された、椎骨ごとのセグメンテーションマスクを格納します。
  - サンプルIDごとにサブディレクトリを作成し、その中に `vertebrae_C1.nii.gz`, `vertebrae_C2.nii.gz` ... のようにファイルを配置します。
- **`fracture_labels/`**:
  - 医師によってアノテーションされた骨折領域のマスク画像を格納します。
  - スライス全体がマスクされていることを想定しています。

## 3. 処理フロー

パイプラインは `nifti_list.csv` に記載されたサンプルIDごとに、以下の処理を順次実行します。

### 3.1. データ読み込み

- CT画像 (`.nii.gz`) と対応する骨折ラベルマスクを読み込みます。

### 3.2. 全椎骨の重心計算

- 各頸椎（C1〜C7）のセグメンテーションマスクを読み込みます。
- ノイズを除去するため、マスクの最大連結成分のみを抽出します。
- 各椎骨マスクの物理座標系（mm）における重心を計算します。

### 3.3. 椎骨ごとのボリューム切り出し

C1からC7までの各椎骨に対して、以下の処理をループで実行します。

1.  **方向ベクトルの計算**:
    - 脊椎の局所的な方向を定義するため、対象の椎骨とその一つ下の椎骨の重心を結ぶベクトルを計算します（例: C4の場合、C5とC4の重心を結ぶ）。
    - このベクトルを正規化し、Z軸（頭尾方向）の基準とします。
    - C1, C2は形状が特殊なため、C3の方向ベクトルを代用します。

2.  **回転行列の計算**:
    - 上記で計算した方向ベクトルが、新しい座標系のZ軸 `(0, 0, 1)` に向くように、3D回転行列を計算します。

3.  **アフィン変換行列の構築**:
    - 対象椎骨の重心が新しいボリュームの中心に来るように、かつステップ2で計算した回転行列に従って椎骨の向きが補正されるように、リサンプリング用の4x4アフィン変換行列を構築します。

4.  **ボリュームの切り出しとチャンネル生成**:
    - 構築したアフィン変換行列を用いて、元のCT画像から `128x128x64 mm` のサイズの3Dボリュームを切り出します（リサンプリング）。
    - この際、以下の3つのチャンネルを持つデータを生成します。
      - **Channel 0: 骨条件 (Bone Window)**: WL 1000, WW 4000 のウィンドウ処理を適用した画像。
      - **Channel 1: 軟部組織条件 (Soft Tissue Window)**: WL 40, WW 400 のウィンドウ処理を適用した画像。
      - **Channel 2: 椎骨マスク**: 対象の椎骨のセグメンテーションマスク。

5.  **骨折ラベルの判定**:
    - **元の画像空間で**、椎骨マスクと骨折ラベルマスクの重なりを評価します。
    - 椎骨の体積に対する骨折マスクとの重複領域の体積の割合が、しきい値（`FRACTURE_OVERLAP_THRESHOLD = 0.10`）を超えた場合、その椎骨のラベルを「骨折あり(1)」とします。それ以外は「骨折なし(0)」です。

### 3.4. 保存

- 各椎骨について生成されたデータを、以下の形式で出力します。

## 4. 出力ファイル

処理が完了すると、`output_dir`（デフォルト: `./spine_data`）に以下のファイルが生成されます。

```
spine_data/
├── dataset_metadata.csv      # 生成された全データのメタ情報
├── slice_annotations.csv     # スライスごとの骨折アノテーション
└── {sample_id}/
    ├── C1.npy
    ├── C1_bone.nii.gz
    ├── C1_mask.nii.gz
    ├── C2.npy
    ...
```

### 各ファイルの詳細

- **`{vertebra}.npy`**:
  - AIモデルの学習に直接使用するnumpy配列。
  - 配列の形状は `(チャンネル数, 深さ, 高さ, 幅)` = `(3, 64, 128, 128)` になっています（Z, Y, Xの順）。
- **`{vertebra}_bone.nii.gz`, `{vertebra}_mask.nii.gz`**:
  - 切り出されたボリュームを確認するためのNIfTIファイル。ITK-SNAPなどのビューアで可視化できます。
  - それぞれ骨条件の画像と、椎骨マスクに対応します。
- **`dataset_metadata.csv`**:
  - 生成された全データの情報をまとめたCSVファイル。以下のカラムが含まれます。
    - `sample_id`: サンプルID
    - `vertebra`: 椎骨ID (C1-C7)
    - `fracture_label`: 骨折ラベル (0 or 1)
    - `fracture_overlap_ratio`: 骨折ラベル判定に用いた重なり率
    - `file_path`: 対応する `.npy` ファイルへのパス
- **`slice_annotations.csv.csv`**:
  -作成された椎骨ボリュームで、どこに、骨折があるか、スライス単位のアノテーションファイル。

## 5. 実行方法

以下のコマンドを実行することで、パイプラインが開始します。

```bash
uv run python generate_dataset.py
```
