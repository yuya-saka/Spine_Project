# 頸椎データ前処理パイプライン計画書

## 前提条件

- 入力されるNIfTIデータ (`.nii.gz`) は、スライス順序等の整列が完了している。
    
- `nifti_list.csv` の `FractureStart` / `FractureEnd` は、このNIfTI画像のZ軸インデックスと整合性が取れている（そのまま適用可能である）。
    
---

## Phase 0: 正解ラベルの3Dマスク化（Label Generation）

**目的:** CSVの数値情報を、画像処理で扱える「3Dバイナリマスク」に変換します。

1. **入力:** NIfTI画像 (`ct.nii.gz`)、CSVデータ
    
2. **処理:**
    
    - 画像と同じサイズ $(X, Y, Z)$ のゼロ配列を作成。
        
    - CSVの `FractureStart` から `FractureEnd` までの範囲に対応するZスライスを全て `1` に設定します。
        
    - _※ここでの座標反転等の計算は不要（前提より）。_
        
3. **出力:** `fracture_label.nii.gz`
    
    - これ以降、このマスクはCT画像と常にペアで処理されます。
        
---

## Phase 1: TotalSegmentatorによる解剖学的マスク生成

1. **実行:** CT画像に対して TotalSegmentator を実行。
    
2. **出力:** `vertebrae_C1.nii.gz` 〜 `vertebrae_C7.nii.gz`
    
    - 高精度の回転を行うため、標準モード（`-fast`なし）推奨。
        
---

## Phase 2: 解像度の統一（Isotropic Resampling）

目的: 全てのデータを $1.0 \times 1.0 \times 1.0$ mm の等方性ボクセルに変換します。

※スライス順序の変更は行いません。

1. **処理対象:**
    
    - CT画像
        
    - C1〜C7マスク
        
    - 骨折ラベルマスク (`fracture_label.nii.gz`)
        
2. **処理内容:**
    
    - 全てのデータを $1.0mm$ 等方性にリサンプリング。
        
    - ※必要であればヘッダー情報のOrientation（RAS等）を統一しますが、データの並び替え（Sorting）は行いません。
        
3. **⚠️ 補間モード（重要）:**
    
    - **CT画像:** `Spline order 3` (推奨) または `Linear`
        
    - **マスク類（椎骨・骨折ラベル）:** 必ず **`Nearest Neighbor`** (0/1を維持するため)
        
---

## Phase 3: 幾何学情報の算出（Geometry Calculation）

**目的:** 各椎骨の「中心」と「傾き」を計算します。

1. **重心 (Centroid) の取得**
    
    - リサンプリング後の各椎骨マスクから重心 $(x, y, z)$ を計算。
        
2. **傾きベクトル $\vec{v}$ の計算**
    
    - **C3 〜 C7:** 上下の椎骨（または隣接椎骨）の重心を結ぶベクトルを使用。
        
    - **C1 (Atlas) & C2 (Axis) の特例:**
        
        - 形状が特異なため、自己の重心計算ではなく**「画像のZ軸 $(0,0,1)$」**または**「C3の傾き」**を代用して安定化させます。
            
---

## Phase 4: 個別回転と切り出し (Dual Stream Processing)

**目的:** 各椎骨を直立させ、画像と**「骨折ラベル」を同時に**切り出します。

各椎骨（C1〜C7）に対してループ処理：

1. **変換行列の作成**
    
    - [重心を原点へ] $\times$ [ベクトルをZ軸へ回転] $\times$ [原点を出力BOX中心へ] のアフィン行列 $M$ を作成。
        
2. **CT画像の切り出し**
    
    - 行列 $M$ を適用。
        
    - サイズ: $128^3$
        
    - 補間: `Spline order 3`
        
3. **骨折ラベルの切り出し（同期処理）**
    
    - **同じ行列 $M$** を適用して `fracture_label.nii.gz` を切り出し。
        
    - サイズ: $128^3$
        
    - 補間: `Nearest Neighbor`
        
    - **判定:** 切り出されたBOX内に `1` が存在すれば、その椎骨データの正解ラベルを `Positive (1)` とします。
        
---

## Phase 5: 正規化・出力

1. **Windowing & Normalization**
    
    - Bone Window (WL: 1000, WW: 4000) を適用し、0〜1に正規化。
        
2. **出力データ:**
    
    - `input`: (1, 128, 128, 128) のCTテンソル
        
    - `target`: 0 または 1 （あるいは骨折マスクそのもの）
        
---

### この変更によるメリット

- **シンプル:** 座標反転のバグ混入リスクがなくなりました。
    
- **堅実:** ラベルを画像（マスク）として扱うため、回転・拡大縮小を行っても、骨折位置と画像位置のズレが原理的に発生しません。









# "重要" plan phase2から修正

# Phase 2: 空間情報の定義と行列準備

**目的:** 実際に画像を変形させるのではなく、**「元画像空間」と「理想の1mm等方空間」をつなぐ変換式（Affine行列）**を準備します。

### 1. データの読み込み

- 対象:
    
    - 元画像 (`ct.nii.gz`)
        
    - 各椎骨マスク (`vertebrae_C1.nii.gz` 〜 `C7`)
        
    - 骨折ラベルマスク (`fracture_label.nii.gz`) ※Phase 0で作成済み前提
        
- **取得情報:**
    
    - 画像の3次元配列 (`data`)
        
    - **Affine行列 (4x4)** (`obj.affine`): 画像の「インデックス(i,j,k)」を「物理座標(x,y,z mm)」に変換する行列です。
        

### 2. 「理想の向き」の定義

- すべての画像における「標準座標系 (RAS axes)」を定義します。
    
- Nibabel等のライブラリを使い、現在のAffine行列がRAS向きかどうかを確認します（`nib.as_closest_canonical` のロジックを使用）。
    
- **重要:** ここではデータの並べ替え（Resampling）は実行しません。「もしRAS・1mmにするなら、こういう変換行列になる」という **$M_{iso}$ (4x4行列)** だけを計算して保持します。
    

---

# Phase 3: 幾何学パラメータの算出 (ROI Calculation)

**目的:** 「どの位置（重心）」を「どの角度（回転）」で切り出すかを、物理座標（mm）ベースで計算します。

### 1. 物理重心 (Physical Centroid) の計算

マスク画像は元画像と同じ空間にあるため、以下の手順で正確な重心を求めます。

1. **インデックス重心:** 各椎骨マスク ($C1 \dots C7$) から `scipy.ndimage.center_of_mass` で配列上の中心 $(i, j, k)$ を取得。
    
2. **物理変換:** 元画像のAffine行列を使って、$(i, j, k)$ を物理座標 $(x, y, z)$ に変換します。
    
    - 式: $\text{Point}_{mm} = \text{Affine} \times \text{Point}_{index}$
        
    - これで、「C3の重心は $(120.5, -30.2, 400.0)$ mm」といった世界共通の座標が手に入ります。
        

### 2. 回転行列 (Rotation Matrix) の算出

取得した物理重心を使って、各椎骨の傾きを計算します。

- **C3 〜 C7:**
    
    - ベクトル $\vec{v} = \text{Centroid}_{\text{Upper}} - \text{Centroid}_{\text{Lower}}$
        
    - この $\vec{v}$ を、ターゲット空間のZ軸 $(0, 0, 1)$ に合わせる回転行列 $R$ を算出（`scipy.spatial.transform.Rotation` を使用）。
        
- **C1 & C2 (特例処理):**
    
    - 不安定な形状のため、自身の重心を使わず、**C3のベクトル（またはC3の回転行列そのもの）**を流用します。
        
    - これにより、C1/C2が変な方向に回転して見切れる事故を防ぎます。
        

### 3. 合成行列 (Final Matrix) の作成

ここが「ワンショット変換」の核心です。以下の3つの変換を1つの行列 $M_{total}$ にまとめます。

1. **$T_{1}$ (Center to Origin):** 椎骨の物理重心を原点 $(0,0,0)$ へ移動。
    
2. **$R$ (Rotation):** 傾きを補正して直立させる。
    
3. **$T_{2}$ (Origin to Box):** 原点を、出力ボックスの中心（例: $64, 64, 32$）へ移動。
    

$$M_{total} = T_{2} \cdot R \cdot T_{1}$$

この行列があれば、元画像がどんな解像度・向きであっても、一発で「直立した椎骨」へ変換できます。

---

# Phase 4: ワンショット切り出しと保存 (Generation)

目的: 計算した行列 $M_{total}$ を使い、実際にデータを生成します。

出力サイズ: $128 \times 128 \times 64$ (mm) ※Z軸は64mmで十分カバー可能

### 1. ターゲットグリッドの作成

- $128 \times 128 \times 64$ の空のグリッドを用意します。
    

### 2. チャンネルごとのサンプリング (3-Channel Input)

作成した $M_{total}$ の **逆行列 (Inverse Matrix)** を使い、`affine_transform` で元画像から値を引っぱってきます。

- **Channel 1: Bone Window (骨情報)**
    
    - **ソース:** 元のCT画像
        
    - **補間:** Spline order 3 (高画質)
        
    - **パディング:** -1024 (空気)
        
    - **後処理:** Windowing (WL: 1000, WW: 4000) → 0~1正規化
        
- **Channel 2: Soft Tissue Window (出血・腫れ情報)**
    
    - **ソース:** 元のCT画像（Ch1と同じもの）
        
    - **補間:** Spline order 3
        
    - **パディング:** -1024
        
    - **後処理:** Windowing (WL: 40, WW: 400) → 0~1正規化
        
- **Channel 3: ROI Mask (注目椎骨のマスク)**
    
    - **ソース:** 対象となる椎骨のマスクファイル（例: C3切り出しなら `vertebrae_C3.nii.gz`）
        
    - **補間:** **Nearest Neighbor** (0/1維持)
        
    - **パディング:** 0
        

### 3. 正解ラベルの判定

- **ソース:** 骨折ラベルマスク (`fracture_label.nii.gz`)
    
- **処理:** 同じ $M_{total}$ で切り出し (Nearest Neighbor)。
    
- **判定:** 切り出されたボックス内に `1` が含まれていれば、その椎骨のラベルは `1 (Fracture)`。
    

### 4. 保存 (Saving)

- 3つのチャンネルを結合 (Stack) し、`(3, 64, 128, 128)` の形状で保存します。
    
    - 形式: `.npy` (NumPy) または `.pt` (PyTorch) 推奨。読み込みが高速で